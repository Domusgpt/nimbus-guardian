<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Guardian Dashboard - Holographic Interface</title>
    <script>
        window.__CSRF_TOKEN__ = '__CSRF_TOKEN__';
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --holo-cyan: #00ffff;
            --holo-magenta: #ff00ff;
            --holo-yellow: #ffff00;
            --depth-back: translateZ(-100px);
            --depth-mid: translateZ(0px);
            --depth-front: translateZ(50px);
            --depth-accent: translateZ(100px);
        }

        body {
            background: radial-gradient(ellipse at center, #0a0015 0%, #000000 70%);
            color: white;
            font-family: 'Orbitron', 'Courier New', monospace;
            overflow-x: hidden;
            min-height: 100vh;
            cursor: crosshair;
            perspective: 1200px;
        }

        /* HOLOGRAPHIC DEPTH CONTAINER */
        .holographic-scene {
            position: relative;
            width: 100%;
            min-height: 100vh;
            transform-style: preserve-3d;
            transition: transform 0.3s ease-out;
        }

        /* DEPTH LAYERS */
        .depth-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .depth-layer.background {
            z-index: 1;
            transform: var(--depth-back);
            opacity: 0.4;
            filter: blur(2px);
        }

        .depth-layer.midground {
            z-index: 5;
            transform: var(--depth-mid);
        }

        .depth-layer.foreground {
            z-index: 10;
            transform: var(--depth-front);
        }

        .depth-layer.accent {
            z-index: 15;
            transform: var(--depth-accent);
        }

        /* HEADER - ACCENT LAYER */
        .guardian-header {
            padding: 30px 40px;
            text-align: center;
            background: linear-gradient(135deg,
                rgba(0, 255, 255, 0.05) 0%,
                rgba(255, 0, 255, 0.03) 50%,
                rgba(255, 255, 0, 0.05) 100%
            );
            backdrop-filter: blur(20px);
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow:
                0 10px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 2px rgba(255, 255, 255, 0.1),
                0 0 60px rgba(0, 255, 255, 0.1);
        }

        .guardian-logo {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(45deg, var(--holo-cyan), var(--holo-magenta), var(--holo-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            letter-spacing: 3px;
            margin-bottom: 10px;
            animation: pulse 3s ease-in-out infinite;
        }

        .project-name {
            font-size: 1.2rem;
            color: var(--holo-cyan);
            text-shadow: 0 0 15px var(--holo-cyan);
            letter-spacing: 2px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* MAIN GRID - MIDGROUND LAYER */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            padding: 40px;
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
        }

        /* NEOSKEUOMORPHIC CARDS */
        .neo-card {
            position: relative;
            backdrop-filter: blur(20px);
            border-radius: 25px;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
            transform-style: preserve-3d;
            min-height: 280px;
            cursor: pointer;

            /* Neoskeuomorphic shadow system */
            box-shadow:
                /* Outer depth */
                0 20px 40px rgba(0, 0, 0, 0.6),
                0 8px 16px rgba(0, 0, 0, 0.4),
                /* Inner highlights */
                inset 0 1px 2px rgba(255, 255, 255, 0.15),
                inset 0 -1px 1px rgba(0, 0, 0, 0.2),
                /* Holographic rim */
                0 0 0 1px rgba(0, 255, 255, 0.3),
                0 0 30px rgba(0, 255, 255, 0.15);

            background: linear-gradient(135deg,
                rgba(0, 255, 255, 0.05) 0%,
                rgba(255, 0, 255, 0.03) 50%,
                rgba(0, 255, 255, 0.05) 100%
            );
        }

        .neo-card:hover {
            transform: translateY(-10px) rotateX(3deg) rotateY(2deg);
            box-shadow:
                0 30px 60px rgba(0, 0, 0, 0.7),
                0 12px 24px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 2px rgba(0, 0, 0, 0.25),
                0 0 0 2px rgba(0, 255, 255, 0.5),
                0 0 50px rgba(0, 255, 255, 0.3),
                0 0 100px rgba(255, 0, 255, 0.2);
        }

        .neo-card.active {
            background: linear-gradient(135deg,
                rgba(255, 255, 0, 0.08) 0%,
                rgba(255, 0, 255, 0.06) 50%,
                rgba(255, 255, 0, 0.08) 100%
            );
            box-shadow:
                0 25px 50px rgba(0, 0, 0, 0.7),
                0 10px 20px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.2),
                inset 0 -2px 2px rgba(0, 0, 0, 0.2),
                0 0 0 3px rgba(255, 255, 0, 0.7),
                0 0 60px rgba(255, 255, 0, 0.5);
        }

        .card-header {
            padding: 25px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title {
            font-size: 1.4rem;
            font-weight: 900;
            color: #ffffff;
            text-shadow:
                0 0 15px var(--holo-cyan),
                0 0 30px rgba(0, 255, 255, 0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            backdrop-filter: blur(10px);
            border: 1px solid;
            box-shadow: 0 0 20px currentColor;
        }

        .status-good {
            background: rgba(0, 255, 0, 0.15);
            border-color: #00ff00;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        .status-warning {
            background: rgba(255, 255, 0, 0.15);
            border-color: var(--holo-yellow);
            color: var(--holo-yellow);
            text-shadow: 0 0 10px var(--holo-yellow);
        }

        .status-error {
            background: rgba(255, 0, 0, 0.15);
            border-color: #ff0000;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        .card-body {
            padding: 25px;
        }

        /* METRIC DISPLAYS */
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .metric:hover {
            background: rgba(0, 255, 255, 0.05);
            padding-left: 10px;
            border-left: 3px solid var(--holo-cyan);
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 1px;
        }

        .metric-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--holo-cyan);
            text-shadow: 0 0 10px var(--holo-cyan);
        }

        /* HOLOGRAPHIC PROGRESS BAR */
        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow:
                inset 0 2px 5px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 255, 0.2);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg,
                var(--holo-cyan) 0%,
                var(--holo-magenta) 50%,
                var(--holo-yellow) 100%
            );
            border-radius: 15px;
            box-shadow:
                0 0 20px var(--holo-cyan),
                inset 0 1px 2px rgba(255, 255, 255, 0.3);
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 100%
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 200%; }
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 10;
            letter-spacing: 1px;
        }

        /* ISSUE LIST */
        .issue-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .issue-item {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 4px solid;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
        }

        .issue-item:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        .issue-item.critical {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.05);
        }

        .issue-item.high {
            border-color: #ff9900;
            background: rgba(255, 153, 0, 0.05);
        }

        .issue-item.medium {
            border-color: var(--holo-yellow);
            background: rgba(255, 255, 0, 0.05);
        }

        .issue-icon {
            font-size: 1.5rem;
            filter: drop-shadow(0 0 8px currentColor);
        }

        .issue-text {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .issue-note {
            margin-top: 6px;
            font-size: 0.7rem;
            color: var(--holo-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .issue-file {
            display: block;
            margin-top: 6px;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-word;
        }

        .issue-empty {
            justify-content: center;
            text-align: center;
            border-color: transparent;
            background: rgba(255, 255, 255, 0.05);
        }

        .error-message {
            color: #ff6b6b;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        .empty-state {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            text-align: center;
            letter-spacing: 1px;
        }

        .tool-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .tool-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 18px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            gap: 12px;
        }

        .tool-details {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
        }

        .tool-name {
            font-size: 0.85rem;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--holo-cyan);
        }

        .tool-status {
            font-size: 0.75rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .tool-status.installed {
            color: #00ff85;
            text-shadow: 0 0 8px #00ff85;
        }

        .tool-status.missing {
            color: var(--holo-yellow);
            text-shadow: 0 0 8px var(--holo-yellow);
        }

        .tool-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tool-note {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.65);
        }

        /* HOLOGRAPHIC BUTTONS */
        .holo-button {
            padding: 12px 24px;
            background: linear-gradient(135deg,
                rgba(0, 255, 255, 0.2) 0%,
                rgba(255, 0, 255, 0.15) 50%,
                rgba(0, 255, 255, 0.2) 100%
            );
            border: 2px solid var(--holo-cyan);
            border-radius: 15px;
            color: var(--holo-cyan);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--holo-cyan);
            backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow:
                0 5px 15px rgba(0, 0, 0, 0.3),
                inset 0 1px 2px rgba(255, 255, 255, 0.2),
                0 0 20px rgba(0, 255, 255, 0.3);
        }

        .holo-button:hover {
            transform: translateY(-3px) scale(1.05);
            background: linear-gradient(135deg,
                rgba(0, 255, 255, 0.3) 0%,
                rgba(255, 0, 255, 0.25) 50%,
                rgba(0, 255, 255, 0.3) 100%
            );
            box-shadow:
                0 10px 25px rgba(0, 255, 255, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                0 0 40px rgba(0, 255, 255, 0.5);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .holo-button:active {
            transform: translateY(0) scale(0.98);
            box-shadow:
                0 3px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(0, 0, 0, 0.2),
                0 0 30px rgba(255, 255, 0, 0.5);
            border-color: var(--holo-yellow);
        }

        .holo-button[disabled] {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* LOADING SPINNER */
        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            margin: 0 auto 20px;
            border: 4px solid rgba(0, 255, 255, 0.2);
            border-top: 4px solid var(--holo-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 30px var(--holo-cyan);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* BACKGROUND AMBIENT PARTICLES */
        .ambient-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.3;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--holo-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--holo-cyan);
            animation: float 10s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-20px) translateX(10px); }
            50% { transform: translateY(-40px) translateX(-10px); }
            75% { transform: translateY(-20px) translateX(10px); }
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
            }

            .guardian-logo {
                font-size: 2rem;
            }

            .neo-card {
                min-height: 250px;
            }
        }

        /* DEPTH INDICATOR */
        .depth-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 0.7rem;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--holo-cyan);
            color: var(--holo-cyan);
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <!-- Ambient Particles Background -->
    <div class="ambient-particles" id="particles"></div>

    <!-- Depth Indicator -->
    <div class="depth-indicator">
        3D Depth: Active | Mouse: (<span id="mouseX">0</span>, <span id="mouseY">0</span>)
    </div>

    <!-- Main Holographic Scene -->
    <div class="holographic-scene" id="scene">

        <!-- ACCENT LAYER - Header -->
        <div class="depth-layer accent">
            <div class="guardian-header">
                <div class="guardian-logo">üõ°Ô∏è GUARDIAN</div>
                <div class="project-name" id="project-name">Loading...</div>
            </div>
        </div>

        <!-- FOREGROUND LAYER - Primary Cards -->
        <div class="depth-layer foreground">
            <div class="dashboard-grid">

                <!-- Status Card -->
                <div class="neo-card" id="status-card">
                    <div class="card-header">
                        <div class="card-title">üìä Status</div>
                        <div class="status-badge status-good" id="status-badge">Loading...</div>
                    </div>
                    <div class="card-body">
                        <div id="status-content" class="loading">
                            <div class="spinner"></div>
                            <p>Analyzing project...</p>
                        </div>
                    </div>
                </div>

                <!-- Security Scan Card -->
                <div class="neo-card" id="security-card">
                    <div class="card-header">
                        <div class="card-title">üõ°Ô∏è Security</div>
                        <div class="status-badge status-good" id="security-badge">Scanning...</div>
                    </div>
                    <div class="card-body">
                        <div id="security-content" class="loading">
                            <div class="spinner"></div>
                            <p>Scanning for threats...</p>
                        </div>
                    </div>
                </div>

                <!-- Tools Card -->
                <div class="neo-card" id="tools-card">
                    <div class="card-header">
                        <div class="card-title">üîß Tools</div>
                        <div class="status-badge status-good" id="tools-badge">Detecting...</div>
                    </div>
                    <div class="card-body">
                        <div id="tools-content" class="loading">
                            <div class="spinner"></div>
                            <p>Detecting tools...</p>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- MIDGROUND LAYER - Secondary Info -->
        <div class="depth-layer midground">
            <div class="dashboard-grid" style="margin-top: 500px;">

                <!-- Issues Card -->
                <div class="neo-card" style="grid-column: 1 / -1;" id="issues-card">
                    <div class="card-header">
                        <div class="card-title">‚ö†Ô∏è Issues</div>
                        <button class="holo-button" id="rescan-button">Rescan</button>
                    </div>
                    <div class="card-body">
                        <div id="issues-content" class="loading">
                            <div class="spinner"></div>
                            <p>Loading issues...</p>
                        </div>
                    </div>
                </div>

            </div>
        </div>

    </div>

        <script>

const scene = document.getElementById('scene');
const mouseXDisplay = document.getElementById('mouseX');
const mouseYDisplay = document.getElementById('mouseY');
let isCardHovered = false;

document.querySelectorAll('.neo-card').forEach(card => {
    card.addEventListener('mouseenter', () => {
        isCardHovered = true;
    });
    card.addEventListener('mouseleave', () => {
        isCardHovered = false;
    });
});

document.addEventListener('mousemove', (e) => {
    const x = (e.clientX / window.innerWidth - 0.5) * 8;
    const y = (e.clientY / window.innerHeight - 0.5) * 8;

    if (!isCardHovered) {
        scene.style.transform = `rotateY(${x}deg) rotateX(${-y}deg)`;
    }

    mouseXDisplay.textContent = Math.round(x);
    mouseYDisplay.textContent = Math.round(y);
});

const particlesContainer = document.getElementById('particles');
for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.left = Math.random() * 100 + '%';
    particle.style.top = Math.random() * 100 + '%';
    particle.style.animationDelay = Math.random() * 10 + 's';
    particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
    particlesContainer.appendChild(particle);
}

document.querySelectorAll('.neo-card').forEach(card => {
    card.addEventListener('click', function (e) {
        if (e.target.closest('button')) {
            return;
        }
        this.classList.toggle('active');
    });
});

const rescanButton = document.getElementById('rescan-button');
if (rescanButton) {
    rescanButton.addEventListener('click', refreshScan);
}

const dashboardState = {
    status: null,
    tools: null,
    scan: null,
    isScanning: false
};

initializeDashboard();

async function initializeDashboard() {
    await Promise.allSettled([
        loadStatus(),
        loadTools()
    ]);
    await runScan();
}

async function loadStatus() {
    const container = document.getElementById('status-content');
    showLoading(container, 'Analyzing project...');
    try {
        dashboardState.status = await fetchJson('/api/status');
        renderStatus();
    } catch (error) {
        renderError(container, error.message);
        setBadgeState(document.getElementById('status-badge'), 'status-error', 'Error');
    }
}

async function loadTools(skipLoading = false) {
    const container = document.getElementById('tools-content');
    if (!skipLoading) {
        showLoading(container, 'Detecting tools...');
    }
    try {
        dashboardState.tools = await fetchJson('/api/tools');
        renderTools();
    } catch (error) {
        renderError(container, error.message);
        setBadgeState(document.getElementById('tools-badge'), 'status-error', 'Error');
    }
}

async function runScan(interactive = false) {
    if (dashboardState.isScanning) {
        return;
    }

    dashboardState.isScanning = true;
    const securityContainer = document.getElementById('security-content');
    const issuesContainer = document.getElementById('issues-content');
    const securityBadge = document.getElementById('security-badge');
    const rescanButton = document.getElementById('rescan-button');

    if (rescanButton) {
        rescanButton.disabled = true;
    }

    showLoading(securityContainer, interactive ? 'Refreshing security posture...' : 'Scanning for threats...');
    showLoading(issuesContainer, interactive ? 'Refreshing issues...' : 'Loading issues...');
    setBadgeState(securityBadge, 'status-warning', 'Scanning...');

    try {
        dashboardState.scan = await fetchJson('/api/scan', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.__CSRF_TOKEN__
            },
            body: '{}'
        });
        renderSecurity();
        renderIssues();
    } catch (error) {
        renderError(securityContainer, error.message);
        renderError(issuesContainer, error.message);
        setBadgeState(securityBadge, 'status-error', 'Error');
    } finally {
        dashboardState.isScanning = false;
        if (rescanButton) {
            rescanButton.disabled = false;
        }
    }
}

async function refreshScan() {
    const card = document.getElementById('issues-card');
    card.classList.add('active');
    await runScan(true);
    setTimeout(() => card.classList.remove('active'), 600);
}

function renderStatus() {
    const data = dashboardState.status;
    const container = document.getElementById('status-content');
    const badge = document.getElementById('status-badge');

    clearContainer(container);

    if (!data) {
        renderMessage(container, 'Status unavailable.');
        setBadgeState(badge, 'status-warning', 'Pending');
        return;
    }

    document.getElementById('project-name').textContent = data.projectName || 'Unknown Project';

    if (!data.git) {
        setBadgeState(badge, 'status-warning', 'No Git');
    } else if (typeof data.git.uncommitted === 'number' && data.git.uncommitted > 0) {
        setBadgeState(badge, 'status-warning', 'Uncommitted');
    } else {
        setBadgeState(badge, 'status-good', 'Clean');
    }

    const metrics = [
        { label: 'Experience Level', value: formatExperience(data.experienceLevel) },
        { label: 'Dependencies', value: formatCount(data.package?.dependencies) },
        { label: 'Dev Dependencies', value: formatCount(data.package?.devDependencies) },
        { label: 'Branch', value: data.git?.branch || '‚Äî' },
        { label: 'Uncommitted', value: typeof data.git?.uncommitted === 'number' ? data.git.uncommitted : '‚Äî' }
    ];

    renderMetrics(container, metrics);
}

function renderSecurity() {
    const results = dashboardState.scan;
    const container = document.getElementById('security-content');
    const badge = document.getElementById('security-badge');

    clearContainer(container);

    if (!results) {
        renderMessage(container, 'Run a scan to view security insights.');
        setBadgeState(badge, 'status-warning', 'Pending');
        return;
    }

    const counts = { critical: 0, high: 0, medium: 0 };
    (results.issues || []).forEach(issue => {
        const severity = (issue.severity || '').toUpperCase();
        if (severity === 'CRITICAL') counts.critical++;
        else if (severity === 'HIGH') counts.high++;
        else if (severity === 'MEDIUM') counts.medium++;
    });

    const warningsCount = (results.warnings || []).length;

    const severityClass = counts.critical > 0
        ? 'status-error'
        : counts.high > 0
            ? 'status-warning'
            : 'status-good';
    const badgeLabel = counts.critical + counts.high + counts.medium > 0 ? 'Issues Found' : 'Secure';

    setBadgeState(badge, severityClass, badgeLabel);

    const metrics = [
        { label: 'üî¥ Critical', value: counts.critical },
        { label: 'üü† High', value: counts.high },
        { label: 'üü° Medium', value: counts.medium },
        { label: '‚ö™ Warnings', value: warningsCount }
    ];

    renderMetrics(container, metrics);

    const score = Math.max(0, Math.min(100, 100 - (counts.critical * 40 + counts.high * 25 + counts.medium * 15 + warningsCount * 5)));
    container.appendChild(createProgressBar(score));
}

function renderTools() {
    const data = dashboardState.tools;
    const container = document.getElementById('tools-content');
    const badge = document.getElementById('tools-badge');

    clearContainer(container);

    if (!data) {
        renderMessage(container, 'Tool data unavailable.');
        setBadgeState(badge, 'status-warning', 'Pending');
        return;
    }

    const detectedCli = (data.detected || []).filter(tool => tool.category === 'cli' && tool.installed);
    const missing = data.missing || [];

    if (missing.length === 0 && detectedCli.length === 0) {
        renderMessage(container, 'No CLI tools detected yet.');
        setBadgeState(badge, 'status-warning', 'No Data');
        return;
    }

    const list = document.createElement('ul');
    list.className = 'tool-list';

    detectedCli.forEach(tool => {
        const item = document.createElement('li');
        item.className = 'tool-item';

        const details = document.createElement('div');
        details.className = 'tool-details';

        const name = document.createElement('div');
        name.className = 'tool-name';
        name.textContent = (tool.name || tool.provider || 'Tool').toString();

        const status = document.createElement('span');
        status.className = 'tool-status installed';
        status.textContent = 'Installed';

        details.appendChild(name);
        details.appendChild(status);
        item.appendChild(details);
        list.appendChild(item);
    });

    missing.forEach(tool => {
        const item = document.createElement('li');
        item.className = 'tool-item';

        const details = document.createElement('div');
        details.className = 'tool-details';

        const name = document.createElement('div');
        name.className = 'tool-name';
        name.textContent = (tool.installerLabel || tool.name || tool.cli || tool.provider || 'Tool').toString();

        const status = document.createElement('span');
        status.className = 'tool-status missing';
        status.textContent = 'Missing';

        details.appendChild(name);
        details.appendChild(status);

        if (tool.reason || tool.installerDescription) {
            const note = document.createElement('span');
            note.className = 'tool-note';
            note.textContent = tool.installerDescription || tool.reason;
            details.appendChild(note);
        }

        item.appendChild(details);

        const actions = document.createElement('div');
        actions.className = 'tool-actions';

        if (tool.safeInstallerId) {
            const button = document.createElement('button');
            button.className = 'holo-button';
            button.textContent = 'Install';
            button.addEventListener('click', () => installTool(tool.safeInstallerId, tool.installerLabel || tool.name || tool.cli, button));
            actions.appendChild(button);
        } else {
            const note = document.createElement('span');
            note.className = 'tool-note';
            note.textContent = 'Install manually';
            actions.appendChild(note);
        }

        item.appendChild(actions);
        list.appendChild(item);
    });

    container.appendChild(list);

    if (missing.length === 0) {
        setBadgeState(badge, 'status-good', detectedCli.length ? 'All Ready' : 'No Missing Tools');
    } else {
        setBadgeState(badge, 'status-warning', `${missing.length} Missing`);
    }
}

function renderIssues() {
    const results = dashboardState.scan;
    const container = document.getElementById('issues-content');

    clearContainer(container);

    if (!results) {
        renderMessage(container, 'Run a scan to see issues.');
        return;
    }

    const issues = results.issues || [];

    if (issues.length === 0) {
        renderMessage(container, 'No issues detected. Great job!');
        return;
    }

    const list = document.createElement('ul');
    list.className = 'issue-list';

    const severityIcons = {
        CRITICAL: 'üî¥',
        HIGH: 'üü†',
        MEDIUM: 'üü°'
    };

    issues.slice(0, 10).forEach(issue => {
        const severity = (issue.severity || '').toUpperCase();
        const item = document.createElement('li');
        item.className = `issue-item ${severity.toLowerCase()}`;

        const icon = document.createElement('span');
        icon.className = 'issue-icon';
        icon.textContent = severityIcons[severity] || '‚ö™';

        const text = document.createElement('div');
        text.className = 'issue-text';
        text.textContent = issue.message || 'Issue';

        if (issue.file) {
            const file = document.createElement('span');
            file.className = 'issue-file';
            file.textContent = issue.file;
            text.appendChild(file);
        }

        if (issue.autoFixable) {
            const note = document.createElement('div');
            note.className = 'issue-note';
            note.textContent = 'Auto-fix available';
            text.appendChild(note);
        }

        item.appendChild(icon);
        item.appendChild(text);

        if (issue.autoFixable && issue.id) {
            const button = document.createElement('button');
            button.className = 'holo-button';
            button.textContent = 'Auto-fix';
            button.addEventListener('click', () => fixIssue(issue.id, button));
            item.appendChild(button);
        }

        list.appendChild(item);
    });

    container.appendChild(list);
}

async function fixIssue(issueId, button) {
    if (!issueId) {
        return;
    }

    if (button) {
        button.disabled = true;
        button.textContent = 'Fixing‚Ä¶';
    }

    let fixSucceeded = false;

    try {
        const result = await fetchJson('/api/fix', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.__CSRF_TOKEN__
            },
            body: JSON.stringify({ issueId })
        });

        if (result?.success) {
            fixSucceeded = true;
            alert(result.message || 'Issue fixed successfully.');
        } else {
            throw new Error(result?.message || 'Issue not auto-fixable.');
        }
    } catch (error) {
        alert(`Failed to fix issue: ${error.message}`);
    } finally {
        if (button) {
            button.disabled = false;
            button.textContent = 'Auto-fix';
        }
    }

    if (fixSucceeded) {
        await runScan(true);
    }
}

async function installTool(toolId, toolName, button) {
    if (!toolId) {
        alert('Manual installation required for this tool.');
        return;
    }

    const label = toolName || 'tool';
    if (!confirm(`Install ${label}?`)) {
        return;
    }

    if (button) {
        button.disabled = true;
        button.textContent = 'Installing‚Ä¶';
    }

    try {
        const result = await fetchJson('/api/install-tool', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.__CSRF_TOKEN__
            },
            body: JSON.stringify({ toolId })
        });

        if (!result?.success) {
            throw new Error(result?.message || 'Installation failed.');
        }

        alert(result.message || `${label} installed successfully.`);
        await loadTools(true);
    } catch (error) {
        alert(`Failed to install ${label}: ${error.message}`);
    } finally {
        if (button) {
            button.disabled = false;
            button.textContent = 'Install';
        }
    }
}

function showLoading(container, message) {
    clearContainer(container);
    container.classList.add('loading');

    const spinner = document.createElement('div');
    spinner.className = 'spinner';

    const text = document.createElement('p');
    text.textContent = message;

    container.appendChild(spinner);
    container.appendChild(text);
}

function clearContainer(container) {
    container.classList.remove('loading');
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }
}

function renderError(container, message) {
    clearContainer(container);
    const error = document.createElement('p');
    error.className = 'error-message';
    error.textContent = message;
    container.appendChild(error);
}

function renderMessage(container, message) {
    clearContainer(container);
    const text = document.createElement('div');
    text.className = 'empty-state';
    text.textContent = message;
    container.appendChild(text);
}

function renderMetrics(container, metrics) {
    metrics.forEach(metric => {
        const row = document.createElement('div');
        row.className = 'metric';

        const label = document.createElement('span');
        label.className = 'metric-label';
        label.textContent = metric.label;

        const value = document.createElement('span');
        value.className = 'metric-value';
        value.textContent = metric.value ?? '‚Äî';

        row.appendChild(label);
        row.appendChild(value);
        container.appendChild(row);
    });
}

function createProgressBar(score) {
    const wrapper = document.createElement('div');
    wrapper.className = 'progress-bar';
    wrapper.style.marginTop = '20px';

    const fill = document.createElement('div');
    fill.className = 'progress-fill';
    fill.style.width = `${score}%`;

    const label = document.createElement('div');
    label.className = 'progress-text';
    label.textContent = `${Math.round(score)}% Secure`;

    fill.appendChild(label);
    wrapper.appendChild(fill);
    return wrapper;
}

function setBadgeState(element, variant, text) {
    if (!element) {
        return;
    }
    element.className = `status-badge ${variant}`;
    element.textContent = text;
}

async function fetchJson(url, options = {}) {
    let response;
    try {
        response = await fetch(url, options);
    } catch (error) {
        throw new Error('Network error. Please verify the dashboard server is running.');
    }

    const text = await response.text();
    let payload = null;

    if (text) {
        try {
            payload = JSON.parse(text);
        } catch (error) {
            throw new Error('Server returned invalid JSON.');
        }
    }

    if (!response.ok) {
        const message = payload?.error || payload?.message || `Request failed (${response.status})`;
        throw new Error(message);
    }

    return payload;
}

function formatExperience(value) {
    if (!value) {
        return 'Intermediate';
    }
    const normalized = value.toString().toLowerCase();
    return normalized.charAt(0).toUpperCase() + normalized.slice(1);
}

function formatCount(value) {
    if (typeof value === 'number') {
        return value;
    }
    return '‚Äî';
}
    </script>
</body>
</html>
